/*
 * Algod REST API.
 * API Endpoint for AlgoD Operations.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: contact@algorand.com
 *
 * NOTE: This class is a touched-up version of models generated by swagger-codegen from algod's spec.
 */

package com.algorand.algosdk.algod.model;

import org.apache.commons.lang3.ObjectUtils;
import com.google.gson.annotations.SerializedName;

/**
 * Block contains a block information
 */
public class Block {

  @SerializedName("balRoot")
  private String balRoot = null;

  @SerializedName("currentProtocol")
  private String currentProtocol = null;

  @SerializedName("earn")
  private Long earn = null;

  @SerializedName("frac")
  private Long frac = null;

  @SerializedName("hash")
  private String hash = null;

  @SerializedName("nextProtocol")
  private String nextProtocol = null;

  @SerializedName("nextProtocolApprovals")
  private Long nextProtocolApprovals = null;

  @SerializedName("nextProtocolSwitchOn")
  private Long nextProtocolSwitchOn = null;

  @SerializedName("nextProtocolVoteBefore")
  private Long nextProtocolVoteBefore = null;

  @SerializedName("period")
  private Long period = null;

  @SerializedName("previousBlockHash")
  private String previousBlockHash = null;

  @SerializedName("proposer")
  private String proposer = null;

  @SerializedName("rate")
  private Long rate = null;

  @SerializedName("round")
  private Long round = null;

  @SerializedName("seed")
  private String seed = null;

  @SerializedName("timestamp")
  private Long timestamp = null;

  @SerializedName("txnRoot")
  private String txnRoot = null;

  @SerializedName("txns")
  private TransactionList txns = null;

  @SerializedName("upgradeApprove")
  private Boolean upgradeApprove = null;

  @SerializedName("upgradePropose")
  private String upgradePropose = null;
  public Block balRoot(String balRoot) {
    this.balRoot = balRoot;
    return this;
  }

  

  /**
  * BalanceRoot is the root of the merkle tree after committing this block
  * @return balRoot
  **/
  public String getBalRoot() {
    return balRoot;
  }
  public void setBalRoot(String balRoot) {
    this.balRoot = balRoot;
  }
  public Block currentProtocol(String currentProtocol) {
    this.currentProtocol = currentProtocol;
    return this;
  }

  

  /**
  * CurrentProtocol is a string that represents the current protocol
  * @return currentProtocol
  **/
  public String getCurrentProtocol() {
    return currentProtocol;
  }
  public void setCurrentProtocol(String currentProtocol) {
    this.currentProtocol = currentProtocol;
  }
  public Block earn(Long earn) {
    this.earn = earn;
    return this;
  }

  

  /**
  * EarningsLevel specifies how many earnings, in Algos, have been distributed to each config.Protocol.EarningUnit of Algos since genesis.
  * @return earn
  **/
  public Long getEarn() {
    return earn;
  }
  public void setEarn(Long earn) {
    this.earn = earn;
  }
  public Block frac(Long frac) {
    this.frac = frac;
    return this;
  }

  

  /**
  * The number of leftover Algos after the distribution of EarningsRate/earningUnits Algos for every earning unit in the next round.
  * @return frac
  **/
  public Long getFrac() {
    return frac;
  }
  public void setFrac(Long frac) {
    this.frac = frac;
  }
  public Block hash(String hash) {
    this.hash = hash;
    return this;
  }

  

  /**
  * Hash is the current block hash
  * @return hash
  **/
  public String getHash() {
    return hash;
  }
  public void setHash(String hash) {
    this.hash = hash;
  }
  public Block nextProtocol(String nextProtocol) {
    this.nextProtocol = nextProtocol;
    return this;
  }

  

  /**
  * NextProtocol is a string that represents the next proposed protocol
  * @return nextProtocol
  **/
  public String getNextProtocol() {
    return nextProtocol;
  }
  public void setNextProtocol(String nextProtocol) {
    this.nextProtocol = nextProtocol;
  }
  public Block nextProtocolApprovals(Long nextProtocolApprovals) {
    this.nextProtocolApprovals = nextProtocolApprovals;
    return this;
  }

  

  /**
  * NextProtocolApprovals is the number of blocks which approved the protocol upgrade
  * @return nextProtocolApprovals
  **/
  public Long getNextProtocolApprovals() {
    return nextProtocolApprovals;
  }
  public void setNextProtocolApprovals(Long nextProtocolApprovals) {
    this.nextProtocolApprovals = nextProtocolApprovals;
  }
  public Block nextProtocolSwitchOn(Long nextProtocolSwitchOn) {
    this.nextProtocolSwitchOn = nextProtocolSwitchOn;
    return this;
  }

  

  /**
  * NextProtocolSwitchOn is the round on which the protocol upgrade will take effect
  * @return nextProtocolSwitchOn
  **/
  public Long getNextProtocolSwitchOn() {
    return nextProtocolSwitchOn;
  }
  public void setNextProtocolSwitchOn(Long nextProtocolSwitchOn) {
    this.nextProtocolSwitchOn = nextProtocolSwitchOn;
  }
  public Block nextProtocolVoteBefore(Long nextProtocolVoteBefore) {
    this.nextProtocolVoteBefore = nextProtocolVoteBefore;
    return this;
  }

  

  /**
  * NextProtocolVoteBefore is the deadline round for this protocol upgrade (No votes will be consider after this round)
  * @return nextProtocolVoteBefore
  **/
  public Long getNextProtocolVoteBefore() {
    return nextProtocolVoteBefore;
  }
  public void setNextProtocolVoteBefore(Long nextProtocolVoteBefore) {
    this.nextProtocolVoteBefore = nextProtocolVoteBefore;
  }
  public Block period(Long period) {
    this.period = period;
    return this;
  }

  

  /**
  * Period is the period on which the block was confirmed
  * @return period
  **/
  public Long getPeriod() {
    return period;
  }
  public void setPeriod(Long period) {
    this.period = period;
  }
  public Block previousBlockHash(String previousBlockHash) {
    this.previousBlockHash = previousBlockHash;
    return this;
  }

  

  /**
  * PreviousBlockHash is the previous block hash
  * @return previousBlockHash
  **/
  public String getPreviousBlockHash() {
    return previousBlockHash;
  }
  public void setPreviousBlockHash(String previousBlockHash) {
    this.previousBlockHash = previousBlockHash;
  }
  public Block proposer(String proposer) {
    this.proposer = proposer;
    return this;
  }

  

  /**
  * Proposer is the address of this block proposer
  * @return proposer
  **/
  public String getProposer() {
    return proposer;
  }
  public void setProposer(String proposer) {
    this.proposer = proposer;
  }
  public Block rate(Long rate) {
    this.rate = rate;
    return this;
  }

  

  /**
  * The number of new Algos added to the participation stake from earnings at the next round.
  * @return rate
  **/
  public Long getRate() {
    return rate;
  }
  public void setRate(Long rate) {
    this.rate = rate;
  }
  public Block round(Long round) {
    this.round = round;
    return this;
  }

  

  /**
  * Round is the current round on which this block was appended to the chain
  * @return round
  **/
  public Long getRound() {
    return round;
  }
  public void setRound(Long round) {
    this.round = round;
  }
  public Block seed(String seed) {
    this.seed = seed;
    return this;
  }

  

  /**
  * Seed is the sortition seed
  * @return seed
  **/
  public String getSeed() {
    return seed;
  }
  public void setSeed(String seed) {
    this.seed = seed;
  }
  public Block timestamp(Long timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  

  /**
  * TimeStamp in seconds since epoch
  * @return timestamp
  **/
  public Long getTimestamp() {
    return timestamp;
  }
  public void setTimestamp(Long timestamp) {
    this.timestamp = timestamp;
  }
  public Block txnRoot(String txnRoot) {
    this.txnRoot = txnRoot;
    return this;
  }

  

  /**
  * TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it&#x27;s the root of a merkle tree whose leaves are the block&#x27;s Txids, in lexicographic order. For the empty block, it&#x27;s 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.
  * @return txnRoot
  **/

  public String getTxnRoot() {
    return txnRoot;
  }
  public void setTxnRoot(String txnRoot) {
    this.txnRoot = txnRoot;
  }
  public Block txns(TransactionList txns) {
    this.txns = txns;
    return this;
  }

  

  /**
  * Get txns
  * @return txns
  **/
  public TransactionList getTxns() {
    return txns;
  }
  public void setTxns(TransactionList txns) {
    this.txns = txns;
  }
  public Block upgradeApprove(Boolean upgradeApprove) {
    this.upgradeApprove = upgradeApprove;
    return this;
  }

  

  /**
  * UpgradeApprove indicates a yes vote for the current proposal
  * @return upgradeApprove
  **/
  public Boolean isUpgradeApprove() {
    return upgradeApprove;
  }
  public void setUpgradeApprove(Boolean upgradeApprove) {
    this.upgradeApprove = upgradeApprove;
  }
  public Block upgradePropose(String upgradePropose) {
    this.upgradePropose = upgradePropose;
    return this;
  }

  

  /**
  * UpgradePropose indicates a proposed upgrade
  * @return upgradePropose
  **/
  public String getUpgradePropose() {
    return upgradePropose;
  }
  public void setUpgradePropose(String upgradePropose) {
    this.upgradePropose = upgradePropose;
  }
  @Override
  public boolean equals(java.lang.Object o) {
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
    Block block = (Block) o;
    return ObjectUtils.equals(this.balRoot, block.balRoot) &&
    ObjectUtils.equals(this.currentProtocol, block.currentProtocol) &&
    ObjectUtils.equals(this.earn, block.earn) &&
    ObjectUtils.equals(this.frac, block.frac) &&
    ObjectUtils.equals(this.hash, block.hash) &&
    ObjectUtils.equals(this.nextProtocol, block.nextProtocol) &&
    ObjectUtils.equals(this.nextProtocolApprovals, block.nextProtocolApprovals) &&
    ObjectUtils.equals(this.nextProtocolSwitchOn, block.nextProtocolSwitchOn) &&
    ObjectUtils.equals(this.nextProtocolVoteBefore, block.nextProtocolVoteBefore) &&
    ObjectUtils.equals(this.period, block.period) &&
    ObjectUtils.equals(this.previousBlockHash, block.previousBlockHash) &&
    ObjectUtils.equals(this.proposer, block.proposer) &&
    ObjectUtils.equals(this.rate, block.rate) &&
    ObjectUtils.equals(this.round, block.round) &&
    ObjectUtils.equals(this.seed, block.seed) &&
    ObjectUtils.equals(this.timestamp, block.timestamp) &&
    ObjectUtils.equals(this.txnRoot, block.txnRoot) &&
    ObjectUtils.equals(this.txns, block.txns) &&
    ObjectUtils.equals(this.upgradeApprove, block.upgradeApprove) &&
    ObjectUtils.equals(this.upgradePropose, block.upgradePropose);
  }

  @Override
  public int hashCode() {
    return ObjectUtils.hashCodeMulti(balRoot, currentProtocol, earn, frac, hash, nextProtocol, nextProtocolApprovals, nextProtocolSwitchOn, nextProtocolVoteBefore, period, previousBlockHash, proposer, rate, round, seed, timestamp, txnRoot, txns, upgradeApprove, upgradePropose);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Block {\n");
    
    sb.append("    balRoot: ").append(toIndentedString(balRoot)).append("\n");
    sb.append("    currentProtocol: ").append(toIndentedString(currentProtocol)).append("\n");
    sb.append("    earn: ").append(toIndentedString(earn)).append("\n");
    sb.append("    frac: ").append(toIndentedString(frac)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    nextProtocol: ").append(toIndentedString(nextProtocol)).append("\n");
    sb.append("    nextProtocolApprovals: ").append(toIndentedString(nextProtocolApprovals)).append("\n");
    sb.append("    nextProtocolSwitchOn: ").append(toIndentedString(nextProtocolSwitchOn)).append("\n");
    sb.append("    nextProtocolVoteBefore: ").append(toIndentedString(nextProtocolVoteBefore)).append("\n");
    sb.append("    period: ").append(toIndentedString(period)).append("\n");
    sb.append("    previousBlockHash: ").append(toIndentedString(previousBlockHash)).append("\n");
    sb.append("    proposer: ").append(toIndentedString(proposer)).append("\n");
    sb.append("    rate: ").append(toIndentedString(rate)).append("\n");
    sb.append("    round: ").append(toIndentedString(round)).append("\n");
    sb.append("    seed: ").append(toIndentedString(seed)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    txnRoot: ").append(toIndentedString(txnRoot)).append("\n");
    sb.append("    txns: ").append(toIndentedString(txns)).append("\n");
    sb.append("    upgradeApprove: ").append(toIndentedString(upgradeApprove)).append("\n");
    sb.append("    upgradePropose: ").append(toIndentedString(upgradePropose)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
